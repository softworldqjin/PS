2월 4일
>
소수점 첫째 자리까지 출력, 둘째 자리에서 반올림함
System.out.printf("%.1f"); 


2월 5일
>
String str = "hello".charAt(3);
4번째 자리 char타입 문자 반환
저장하는 변수와 반환하는 타입이 다르기 때문에 컴파일 에러, String str을 char str으로 바꿔야 됨
char str = "hello".charAt(3);

String str = "hello";
String str1 = str.indexOf(4);
는 문법적으로 잘못 됨
indexOf() 인자에는 문자 또는 문자열이 들어갈 수 있음
int index = str.indexOf("h");

가변객체
StringBuilder sb = new StringBuilder();
sb.append(char c)는 char타입을 받을 수 있도록 오버라이딩되어 있어 인자로 전달 가능하다

문자를 아스키코드(10진수)로 변환
char c = '0';
int result = (int) c;
char타입은 int타입으로 자동 형변환 됨 (int 생략 가능)


11720
>
StringBuilder sb = new StringBuilder();
sb.charAt(숫자)
sb 객체에 저장된 char타입 배열 0번부터 N번까지 char타입으로 반환됨

2675
>
종이에 반복문 for (i = 0; i < count; i++) 이렇게 써놓고
그대로 코드로 옮김.
i를 초기화해야 되는 걸 놓쳤음, 종이에 반복문 쓸 때 생략하지말고 int i = 0 꼭 써놓고 실수 예방하자
int num = Integer.parseInt(String str)
String 타입(char 타입 X) 문자 그대로 int 타입 반환
"3" -> 3


10809
>
for (char c = 'a'; c <= 'z'; c++)

c++에서 일어나는 일
char c = 'a';
c++;

c가 연산에 쓰일 때, int 타입으로 캐스팅
(int) c

+1 연산 수행
97 + 1 = 98

결과를 char 타입으로 캐스팅
c = (char) 98;

1152
>
" hello world".split(" ")
→ ["", "hello", "world"]

공백이 1개여도, 앞에 공백 있으면 split 결과에 빈 문자열이 낀다.
그래서 문자열.trim() 해서 앞뒤 공백 삭제 (맨뒤 공백은 있든 없든 무시함)

*엣지케이스 주의*
첫 줄에 영어 대소문자와 공백으로 이루어진 문자열이 주어진다. 이 문자열의 길이는 1,000,000을 넘지 않는다. 단어는 공백 한 개로 구분되며, 공백이 연속해서 나오는 경우는 없다. 또한 문자열은 공백으로 시작하거나 끝날 수 있다.

문자열(공백 포함).. 공백 문자 문자 도 올 수 있고, 공백 만으로 끝낼 수 있음

만약 공백 만 입력받고, trim()으로 앞뒤 공백 다 삭제하면 ?? 1이 나온다.. 0이 나노는게 맞는데..
그렇다면 삼항 조건식으로 공백만 입력받을 때의 결과를 임의로 설정하자.

split() 인자는 구분자가 아니라 정규식임

String str = "     ";      
str = str.trim();         
String[] arr = str.split(" ");
arr = [""]
arr.length = 1